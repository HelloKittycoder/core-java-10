package sourceAnnotations;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.beans.Introspector;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Set;

/**
 * 8.6 源码级注解处理
 *
 * 这个demo做的事情是：
 * 通过ToStringAnnotationProcessor处理Rectangle、Point类中的@ToString注解，生成ToStrings类，
 * 然后提供给SourceLevelAnnotationDemo调用
 *
 * 使用：
 * cmd命令定位到test/java目录下，依次执行
 * javac -encoding UTF-8 sourceAnnotations/ToStringAnnotationProcessor.java
 * javac -processor sourceAnnotations.ToStringAnnotationProcessor rect/*.java
 * （如果想查看轮次，就写成：javac -XprintRounds -processor sourceAnnotations.ToStringAnnotationProcessor rect/*.java）
 * java rect.SourceLevelAnnotationDemo
 *
 * Created by shucheng on 2020/10/1 21:30
 */
@SupportedAnnotationTypes("sourceAnnotations.ToString")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class ToStringAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment currentRound) {
        if (annotations.size() == 0) return true;
        try {
            JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile("sourceAnnotations.ToStrings");
            try (PrintWriter out = new PrintWriter(sourceFile.openWriter())) {
                out.println("// Automatically generated by sourceAnnotations.ToStringAnnotationProcessor");
                out.println("package sourceAnnotations;");
                out.println("public class ToStrings {");

                for (Element e : currentRound.getElementsAnnotatedWith(ToString.class)) {
                    if (e instanceof TypeElement) {
                        TypeElement te = (TypeElement) e;
                        writeToStringMethod(out, te);
                    }
                }
                out.println("   public static String toString(Object obj) {");
                out.println("       return java.util.Objects.toString(obj);");
                out.println("   }");
                out.println("}");
            }
        } catch (IOException ex) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, ex.getMessage());
        }
        return true;
    }

    private void writeToStringMethod(PrintWriter out, TypeElement te) {
        String className = te.getQualifiedName().toString();
        out.println("   public static String toString(" + className + " obj) {");
        ToString ann = te.getAnnotation(ToString.class);
        out.println("       StringBuilder result = new StringBuilder();");
        if (ann.includeName()) out.println("        result.append(\"" + className + "\");");
        out.println("       result.append(\"[\");");
        boolean first = true;
        for (Element c : te.getEnclosedElements()) {
            String methodName = c.getSimpleName().toString();
            ann = c.getAnnotation(ToString.class);
            if (ann != null) {
                if (first) first = false; else out.println("        result.append(\",\");");
                if (ann.includeName()) {
                    // Turn getWidth to width, isDone to done, getURL into URL
                    String fieldName = Introspector.decapitalize(methodName.replaceAll("^(get|is)", ""));
                    out.println("       result.append(\"" + fieldName + "=\");");
                }
                out.println("       result.append(toString(obj." + methodName + "()));");
            }
        }
        out.println("       result.append(\"]\");");
        out.println("       return result.toString();");
        out.println("   }");
    }
}
